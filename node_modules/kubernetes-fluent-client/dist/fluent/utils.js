"use strict";
// SPDX-License-Identifier: Apache-2.0
// SPDX-FileCopyrightText: 2023-Present The Kubernetes Fluent Client Authors
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getHeaders = getHeaders;
exports.getHTTPSAgent = getHTTPSAgent;
exports.getToken = getToken;
exports.pathBuilder = pathBuilder;
exports.k8sCfg = k8sCfg;
exports.k8sExec = k8sExec;
const client_node_1 = require("@kubernetes/client-node");
const url_1 = require("url");
const undici_1 = require("undici");
const https_1 = require("https");
const fetch_1 = require("../fetch");
const kinds_1 = require("../kinds");
const fs_1 = __importDefault(require("fs"));
const SSA_CONTENT_TYPE = "application/apply-patch+yaml";
const K8S_SA_TOKEN_PATH = "/var/run/secrets/kubernetes.io/serviceaccount/token";
/**
 * Get the headers for a request
 *
 * @param token - the token from @kubernetes/client-node
 * @returns the headers for undici
 */
async function getHeaders(token) {
    let saToken = "";
    if (!token) {
        saToken = await getToken();
    }
    const headers = {
        "Content-Type": "application/json",
        "User-Agent": "kubernetes-fluent-client",
    };
    if (token) {
        headers["Authorization"] = `Bearer ${token}`;
    }
    else if (saToken) {
        headers["Authorization"] = `Bearer ${saToken}`;
    }
    return headers;
}
/**
 * Get the agent for a request
 *
 * @param opts - the request options from node-fetch
 * @returns the agent for undici
 */
function getHTTPSAgent(opts) {
    // In cluster there will be agent - testing or dev no
    const agentOptions = opts.agent instanceof https_1.Agent
        ? {
            ca: opts.agent.options.ca,
            cert: opts.agent.options.cert,
            key: opts.agent.options.key,
        }
        : {
            ca: undefined,
            cert: undefined,
            key: undefined,
        };
    return new undici_1.Agent({
        keepAliveMaxTimeout: 600000,
        keepAliveTimeout: 600000,
        bodyTimeout: 0,
        connect: agentOptions,
    });
}
/**
 * Read the serviceAccount Token
 *
 * @returns token or null
 */
async function getToken() {
    try {
        return (await fs_1.default.promises.readFile(K8S_SA_TOKEN_PATH, "utf8")).trim();
    }
    catch {
        return null;
    }
}
/**
 * Generate a path to a Kubernetes resource
 *
 * @param serverUrl - the URL of the Kubernetes API server
 * @param model - the model to use for the API
 * @param filters - (optional) filter overrides, can also be chained
 * @param excludeName - (optional) exclude the name from the path
 * @returns the path to the resource
 */
function pathBuilder(serverUrl, model, filters, excludeName = false) {
    const matchedKind = filters.kindOverride || (0, kinds_1.modelToGroupVersionKind)(model.name);
    // If the kind is not specified and the model is not a KubernetesObject, throw an error
    if (!matchedKind) {
        throw new Error(`Kind not specified for ${model.name}`);
    }
    // Use the plural property if it exists, otherwise use lowercase kind + s
    const plural = matchedKind.plural || `${matchedKind.kind.toLowerCase()}s`;
    let base = "/api/v1";
    // If the kind is not in the core group, add the group and version to the path
    if (matchedKind.group) {
        if (!matchedKind.version) {
            throw new Error(`Version not specified for ${model.name}`);
        }
        base = `/apis/${matchedKind.group}/${matchedKind.version}`;
    }
    // Namespaced paths require a namespace prefix
    const namespace = filters.namespace ? `namespaces/${filters.namespace}` : "";
    // Name should not be included in some paths
    const name = excludeName ? "" : filters.name;
    // Build the complete path to the resource
    const path = [base, namespace, plural, name].filter(Boolean).join("/");
    // Generate the URL object
    const url = new url_1.URL(path, serverUrl);
    // Add field selectors to the query params
    if (filters.fields) {
        const fieldSelector = Object.entries(filters.fields)
            .map(([key, value]) => `${key}=${value}`)
            .join(",");
        url.searchParams.set("fieldSelector", fieldSelector);
    }
    // Add label selectors to the query params
    if (filters.labels) {
        const labelSelector = Object.entries(filters.labels)
            // Exists set-based operators only include the key
            // See https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#set-based-requirement
            .map(([key, value]) => (value ? `${key}=${value}` : key))
            .join(",");
        url.searchParams.set("labelSelector", labelSelector);
    }
    return url;
}
/**
 * Sets up the kubeconfig and https agent for a request
 *
 * A few notes:
 * - The kubeconfig is loaded from the default location, and can check for in-cluster config
 * - We have to create an agent to handle the TLS connection (for the custom CA + mTLS in some cases)
 * - The K8s lib uses request instead of node-fetch today so the object is slightly different
 *
 * @param method - the HTTP method to use
 * @returns the fetch options and server URL
 */
async function k8sCfg(method) {
    const kubeConfig = new client_node_1.KubeConfig();
    kubeConfig.loadFromDefault();
    const cluster = kubeConfig.getCurrentCluster();
    if (!cluster) {
        throw new Error("No currently active cluster");
    }
    // Get TLS Options
    const opts = await kubeConfig.applyToFetchOptions({
        method,
        headers: {
            // Set the default content type to JSON
            "Content-Type": "application/json",
            // Set the user agent like kubectl does
            "User-Agent": `kubernetes-fluent-client`,
        },
    });
    const symbols = Object.getOwnPropertySymbols(opts.headers);
    const headersMap = symbols
        .map(symbol => Object.getOwnPropertyDescriptor(opts.headers, symbol)?.value)
        .find(value => typeof value === "object" && value !== null);
    const extractedHeaders = {
        Authorization: headersMap?.["Authorization"]?.[0]?.split(" ")[1]
    };
    const undiciRequestUnit = {
        headers: await getHeaders(extractedHeaders["Authorization"]),
        method,
        dispatcher: getHTTPSAgent(opts),
    };
    return { opts: undiciRequestUnit, serverUrl: cluster.server };
}
/**
 * Execute a request against the Kubernetes API server.
 *
 * @param model - the model to use for the API
 * @param filters - (optional) filter overrides, can also be chained
 * @param method - the HTTP method to use
 * @param payload - (optional) the payload to send
 * @param applyCfg - (optional) configuration for the apply method
 *
 * @returns the parsed JSON response
 */
async function k8sExec(model, filters, method, payload, applyCfg = { force: false }) {
    const reconstruct = async (method) => {
        const configMethod = method === "LOG" ? "GET" : method;
        const { opts, serverUrl } = await k8sCfg(configMethod);
        const isPost = method === "POST";
        const baseUrl = pathBuilder(serverUrl.toString(), model, filters, isPost);
        if (method === "LOG") {
            baseUrl.pathname = `${baseUrl.pathname}/log`;
        }
        return {
            serverUrl: baseUrl,
            opts,
        };
    };
    const { opts, serverUrl } = await reconstruct(method);
    const url = serverUrl instanceof url_1.URL ? serverUrl : new url_1.URL(serverUrl);
    switch (opts.method) {
        // PATCH_STATUS is a special case that uses the PATCH method on status subresources
        case "PATCH_STATUS":
            opts.method = "PATCH";
            url.pathname = `${url.pathname}/status`;
            opts.headers["Content-Type"] = client_node_1.PatchStrategy.MergePatch;
            payload = { status: payload.status };
            break;
        case "PATCH":
            opts.headers["Content-Type"] = client_node_1.PatchStrategy.JsonPatch;
            break;
        case "APPLY":
            opts.headers["Content-Type"] = SSA_CONTENT_TYPE;
            opts.method = "PATCH";
            url.searchParams.set("fieldManager", "pepr");
            url.searchParams.set("fieldValidation", "Strict");
            url.searchParams.set("force", applyCfg.force ? "true" : "false");
            break;
    }
    if (payload) {
        opts.body = JSON.stringify(payload);
    }
    const resp = await (0, fetch_1.fetch)(url, opts);
    if (resp.ok) {
        return resp.data;
    }
    if (resp.status === 404 && method === "PATCH_STATUS") {
        resp.statusText =
            "Not Found" + " (NOTE: This error is expected if the resource has no status subresource)";
    }
    throw resp;
}
