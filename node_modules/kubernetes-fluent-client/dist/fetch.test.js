"use strict";
// SPDX-License-Identifier: Apache-2.0
// SPDX-FileCopyrightText: 2023-Present The Kubernetes Fluent Client Authors
Object.defineProperty(exports, "__esModule", { value: true });
const globals_1 = require("@jest/globals");
const http_status_codes_1 = require("http-status-codes");
const fetch_1 = require("./fetch");
const undici_1 = require("undici");
let mockAgent;
(0, globals_1.beforeEach)(() => {
    mockAgent = new undici_1.MockAgent();
    (0, undici_1.setGlobalDispatcher)(mockAgent);
    mockAgent.disableNetConnect();
    const mockClient = mockAgent.get("https://jsonplaceholder.typicode.com");
    mockClient.intercept({ path: "/todos/1", method: "GET" }).reply(http_status_codes_1.StatusCodes.OK, {
        userId: 1,
        id: 1,
        title: "Example title",
        completed: false,
    }, {
        headers: {
            "Content-Type": "application/json; charset=utf-8",
        },
    });
    mockClient.intercept({ path: "/todos", method: "POST" }).reply(http_status_codes_1.StatusCodes.OK, { title: "test todo", userId: 1, completed: false }, {
        headers: {
            "Content-Type": "application/json; charset=utf-8",
        },
    });
    mockClient
        .intercept({ path: "/todos/empty-null", method: "GET" })
        .reply(http_status_codes_1.StatusCodes.OK, undefined);
    mockClient.intercept({ path: "/todos/empty-string", method: "GET" }).reply(http_status_codes_1.StatusCodes.OK, "");
    mockClient.intercept({ path: "/todos/empty-object", method: "GET" }).reply(http_status_codes_1.StatusCodes.OK, {}, {
        headers: {
            "Content-Type": "application/json; charset=utf-8",
        },
    });
    mockClient
        .intercept({ path: "/todos/invalid", method: "GET" })
        .replyWithError(new Error("Something bad happened"));
});
(0, globals_1.afterEach)(async () => {
    try {
        await mockAgent.close();
    }
    catch (error) {
        console.error("Error closing mock agent", error);
    }
});
(0, globals_1.test)("fetch: should return without type data", async () => {
    const url = "https://jsonplaceholder.typicode.com/todos/1";
    const requestOptions = {
        method: "GET",
        headers: {
            hi: "there",
            "content-type": "application/json; charset=UTF-8",
        },
    };
    const { data, ok } = await (0, fetch_1.fetch)(url, requestOptions);
    (0, globals_1.expect)(ok).toBe(true);
    (0, globals_1.expect)(data.title).toBe("Example title");
});
(0, globals_1.test)("fetch: should return parsed JSON response as a specific type", async () => {
    const url = "https://jsonplaceholder.typicode.com/todos/1";
    const requestOptions = {
        method: "GET",
        headers: {
            "Content-Type": "application/json; charset=UTF-8",
        },
    };
    const res = await (0, fetch_1.fetch)(url, requestOptions);
    (0, globals_1.expect)(res.ok).toBe(true);
    (0, globals_1.expect)(res.data.id).toBe(1);
    (0, globals_1.expect)(typeof res.data.title).toBe("string");
    (0, globals_1.expect)(typeof res.data.completed).toBe("boolean");
});
(0, globals_1.test)("fetch: should handle additional request options", async () => {
    const url = "https://jsonplaceholder.typicode.com/todos";
    const requestOptions = {
        method: "POST",
        body: JSON.stringify({
            title: "test todo",
            userId: 1,
            completed: false,
        }),
        headers: {
            "Content-Type": "application/json; charset=UTF-8",
        },
    };
    const res = await (0, fetch_1.fetch)(url, requestOptions);
    (0, globals_1.expect)(res.ok).toBe(true);
    (0, globals_1.expect)(res.data).toStrictEqual({ title: "test todo", userId: 1, completed: false });
});
(0, globals_1.test)("fetch: should handle empty (null) responses", async () => {
    const url = "https://jsonplaceholder.typicode.com/todos/empty-null";
    const resp = await (0, fetch_1.fetch)(url);
    (0, globals_1.expect)(resp.data).toBe("");
    (0, globals_1.expect)(resp.ok).toBe(true);
    (0, globals_1.expect)(resp.status).toBe(http_status_codes_1.StatusCodes.OK);
});
(0, globals_1.test)("fetch: should handle empty (string) responses", async () => {
    const url = "https://jsonplaceholder.typicode.com/todos/empty-string";
    const resp = await (0, fetch_1.fetch)(url);
    (0, globals_1.expect)(resp.data).toBe("");
    (0, globals_1.expect)(resp.ok).toBe(true);
    (0, globals_1.expect)(resp.status).toBe(http_status_codes_1.StatusCodes.OK);
});
(0, globals_1.test)("fetch: should handle empty (object) responses", async () => {
    const url = "https://jsonplaceholder.typicode.com/todos/empty-object";
    const requestOptions = {
        method: "GET",
        headers: {
            "Content-Type": "application/json; charset=UTF-8",
        },
    };
    const resp = await (0, fetch_1.fetch)(url, requestOptions);
    (0, globals_1.expect)(resp.data).toEqual({});
    (0, globals_1.expect)(resp.ok).toBe(true);
    (0, globals_1.expect)(resp.status).toBe(http_status_codes_1.StatusCodes.OK);
});
(0, globals_1.test)("fetch: should handle failed requests without throwing an error", async () => {
    const url = "https://jsonplaceholder.typicode.com/todos/invalid";
    const resp = await (0, fetch_1.fetch)(url);
    (0, globals_1.expect)(resp.data).toBe(undefined);
    (0, globals_1.expect)(resp.ok).toBe(false);
    (0, globals_1.expect)(resp.status).toBe(http_status_codes_1.StatusCodes.BAD_REQUEST);
});
(0, globals_1.test)("fetch wrapper respects MockAgent", async () => {
    const mockClient = mockAgent.get("https://example.com");
    mockClient.intercept({ path: "/test", method: "GET" }).reply(200, { success: true }, {
        headers: {
            "Content-Type": "application/json; charset=utf-8",
        },
    });
    const response = await (0, fetch_1.fetch)("https://example.com/test");
    (0, globals_1.expect)(response.ok).toBe(true);
    (0, globals_1.expect)(response.data).toEqual({ success: true });
});
